
Voynich-Stream (교육용 설계 초안)
=================================
주의: 아래 내용은 새로운 암호 알고리즘 아이디어를 문서화한 것으로,
실제 보안 용도로 사용하면 안 됩니다. 충분한 암호분석과 표준 검증 없이
“강력함”을 보장할 수 없습니다.

개요
----
Voynich-Stream은 바이트 스트림을 입력으로 받아 키와 논스(nonce),
연관 데이터(AD)를 이용해 스트림 키스트림을 생성하고 XOR로 암·복호화합니다.
핵심 목표는 예측 불가능한 상태 혼합, 입력 길이 및 AD 바인딩입니다.

입력
----
- 키 K: 32바이트
- 논스 N: 16바이트 (재사용 금지)
- 연관 데이터 AD: 가변 길이
- 평문 P: 가변 길이

출력
----
- 암호문 C: P와 동일 길이
- 태그 T: 16바이트 (선택)

알고리즘 구성
-------------
1) 초기 상태 S(512비트)
	- S는 16개의 32비트 워드로 구성.
	- S[0..7] = K의 32비트 워드
	- S[8..11] = N의 32비트 워드
	- S[12..15] = 고정 상수 (0xA5A5A5A5, 0x3C3C3C3C, 0x5A5A5A5A, 0xC3C3C3C3)

2) AD 흡수
	- AD를 32비트 워드로 패딩(끝에 0x80, 이후 0x00) 후,
	  각 워드를 S에 흡수: S[i % 16] ^= AD_word; S = permute(S)

3) 키스트림 생성
	- 블록마다:
	  S = permute(S)
	  keystream_block = little_endian(S[0..7])  (총 32바이트)

4) 암·복호화
	- C[i] = P[i] XOR keystream[i]

5) 태그 생성(선택)
	- S에 길이(AD_len, P_len)를 XOR로 주입 후 permute를 2회 실행.
	- T = little_endian(S[8..11]) (16바이트)

permute(S) 정의 (12 라운드)
----------------------------
각 라운드는 다음의 순서로 진행:
  a) Mix
	  for i in 0..15:
		 S[i] = (S[i] + rotl(S[(i+5)%16], 7)) XOR rotl(S[(i+10)%16], 11)
  b) Shuffle
	  S = [S0, S5, S10, S15, S4, S9, S14, S3, S8, S13, S2, S7, S12, S1, S6, S11]
  c) Inject
	  S[0] ^= round_constant[r]
	  S[7] ^= rotl(S[3], 13)
	  S[12] ^= rotl(S[9], 9)

round_constant = [
  0x9E3779B9, 0x7F4A7C15, 0xF39CC060, 0x106AA070,
  0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F,
  0x1F83D9AB, 0x5BE0CD19, 0xC2B2AE3D, 0x27D4EB2F
]

구현 참고
--------
- 모든 연산은 32비트 모듈러 덧셈과 비트회전(rotl) 기반.
- 논스 재사용은 심각한 보안 문제를 야기.
- 실제 보안 용도는 표준화된 알고리즘(AES-GCM, ChaCha20-Poly1305 등)을 사용.
